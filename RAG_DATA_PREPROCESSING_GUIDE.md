# RAG 데이터 정제 가이드

## 개요

이 문서는 Well Dying RAG 챗봇을 위한 파트 중 "유산"관련 데이터의 전처리 과정과 방법, 그리고 각 단계의 이유를 설명합니다.

---

## 1. RAG 시스템의 핵심 요구사항

### 1.1 RAG의 작동 원리
1. **Retrieval (검색)**: 사용자 질문과 유사한 문서 청크를 벡터 DB에서 검색
2. **Augmentation (증강)**: 검색된 청크를 컨텍스트로 LLM에 제공
3. **Generation (생성)**: 컨텍스트를 바탕으로 정확한 답변 생성

### 1.2 데이터 품질의 중요성
- **임베딩 벡터 품질**: 깨끗한 텍스트 → 정확한 벡터 표현
- **검색 정확도**: 의미 단위 보존 → 관련성 높은 결과
- **생성 품질**: 적절한 맥락 → 정확한 답변

---

## 2. 정제 과정 상세 설명

### 단계 1: PDF 텍스트 추출

**방법:**
```python
PyMuPDF(fitz)를 사용한 텍스트 추출
- page.get_text("text") 방식으로 순수 텍스트만 추출
```

**이유:**
- PDF는 레이아웃 정보(좌표, 폰트, 색상 등)가 포함되어 있음
- 레이아웃 기반 추출 시 개행, 공백, 특수문자가 왜곡될 수 있음
- RAG에서는 순수 텍스트만 필요하므로 레이아웃 정보는 불필요

**RAG 영향:**
- 잘못된 개행/공백 → 단어 분리 → 임베딩 벡터 왜곡 → 검색 실패

---

### 단계 2: 제어 문자 제거

**방법:**
```python
1. 일반 제어 문자 제거 (0x00-0x1F, 0x7F-0x9F)
   - 단, \n(개행), \t(탭), \r(캐리지 리턴)은 유지
2. Private Use Area 제거 (U+E000~U+F8FF)
   - PDF에서 사용하는 특수 폰트 문자
```

**이유:**
- 제어 문자는 화면에 표시되지 않지만 임베딩 벡터에 영향을 줌
- Private Use Area 문자는 PDF 특수 폰트로 인한 노이즈
- 검색 시 의미 없는 문자로 인한 검색 품질 저하 방지

**RAG 영향:**
- 제어 문자 포함 → 임베딩 벡터에 불필요한 차원 추가
- 검색 시 노이즈로 작용하여 관련성 점수 하락

**예시:**
```
❌ "상속권\x07" → 제어 문자 포함
✅ "상속권" → 깨끗한 텍스트
```

---

### 단계 3: 한글 단어 중간 개행 복원

**방법:**
```python
1. 한글 + 개행 + 한글 → 개행 제거
   re.sub(r'([가-힣])\n+([가-힣])', r'\1\2', text)
   
2. 숫자 + 개행 + 숫자 → 개행 제거
   re.sub(r'(\d)\n+(\d)', r'\1\2', text)
```

**이유:**
- PDF 추출 시 단어가 줄바꿈으로 인해 분리됨
- 예: "상속\n\n민법권" → "상속권"으로 복원 필요
- 단어가 분리되면 임베딩 벡터가 달라짐

**RAG 영향:**
```
사용자 질문: "상속권에 대해 알려줘"

❌ 분리된 텍스트: "상속\n\n민법권"
   → 임베딩 벡터: [0.1, 0.2, ...] (상속만 인식)
   → 검색 실패

✅ 복원된 텍스트: "상속권"
   → 임베딩 벡터: [0.3, 0.4, ...] (상속권 전체 인식)
   → 검색 성공
```

**예시:**
```
❌ "어느 하\n나에 해당하는 경우"
✅ "어느 하나에 해당하는 경우"

❌ "제1\n\n2조"
✅ "제12조"
```

---

### 단계 4: PDF 헤더/푸터 제거

**방법:**
```python
# 패턴: 한글/숫자 + 개행 + "민법" + 공백 + 원문자/숫자
re.sub(r'([가-힣\d])\n+민법\s+([①②③④⑤⑥⑦⑧⑨⑩]|\d)', r'\1\n\n\2', text)
```

**이유:**
- PDF 헤더/푸터는 문서 본문이 아님
- 예: "2분의 1\n\n민법 3" → "2분의 1\n\n3"
- 헤더/푸터는 검색 시 노이즈가 됨

**RAG 영향:**
```
사용자 질문: "2분의 1에 대해 알려줘"

❌ 헤더 포함: "2분의 1\n\n민법 3"
   → "민법"이라는 불필요한 키워드 포함
   → 검색 시 관련성 점수 하락

✅ 헤더 제거: "2분의 1\n\n3"
   → 본문 내용만 포함
   → 검색 정확도 향상
```

---

### 단계 5: 특수 패턴 정리

#### 5.1 "분의 1" 다음 숫자 분리

**방법:**
```python
# "2분의 12" → "2분의 1\n\n2"
# 단, "100분의 10", "100분의 100"은 보호
```

**이유:**
- PDF 추출 시 숫자가 붙어서 나옴
- 법률 문서의 특수 표현 정확도 보장
- 정상 패턴("100분의 10")은 보호

**RAG 영향:**
```
❌ "2분의 12" → 의미 불명확
✅ "2분의 1\n\n2" → 명확한 의미
```

#### 5.2 "및" 뒤 공백 추가

**방법:**
```python
re.sub(r'및([가-힣])', r'및 \1', text)
```

**이유:**
- "및제" → "및 제"로 복원
- 법률 용어의 정확한 표현

---

### 단계 6: 청킹 전략

#### 6.1 Law 모드 (법령 문서)

**방법:**
```python
1. 조문 단위로 청킹 ("제000조" 패턴 기준)
2. 조문이 500자 초과 시:
   - 문단 단위로 분할 (\n\n 기준)
   - 문단이 500자 초과 시 문장 단위로 분할
   - 문장이 500자 초과 시 쉼표/연결어 기준으로 분할
```

**이유:**
- 법조문은 조문 단위가 의미 단위
- 조문 단위 검색이 효과적
- 예: "제1112조 유류분의 권리자와 유류분"

**RAG 영향:**
```
사용자 질문: "유류분에 대해 알려줘"

✅ 조문 단위 청킹:
   청크 1: "제1112조 유류분의 권리자와 유류분 ..."
   → 정확한 조문 단위 검색
   → 관련성 높은 결과

❌ 무작위 청킹:
   청크 1: "제1112조 유류분의 권리자와 유류분의 권리자와 유류분의 권리자와..."
   → 조문 경계 무시
   → 검색 정확도 하락
```

#### 6.2 Simple 모드 (일반 문서)

**방법:**
```python
1. 문단 기준 청킹 (\n\n 기준)
2. 문단이 500자 초과 시:
   - 문장 단위로 분할
   - 문장이 500자 초과 시 쉼표/연결어 기준으로 분할
```

**이유:**
- 일반 문서는 문단이 자연스러운 의미 단위
- 문단 단위 검색이 효과적

---

### 단계 7: 길이 제한 (500자)

**방법:**
```python
모든 청크를 500자 이하로 제한
- 너무 짧은 청크(20자 미만)는 제외
```

**이유:**
1. **임베딩 모델의 토큰 제한**
   - 대부분의 임베딩 모델은 512 토큰 제한
   - 한글 기준 약 500자 = 500 토큰

2. **검색 정확도**
   - 너무 긴 청크 → 불필요한 정보 포함
   - 너무 짧은 청크 → 맥락 손실

3. **생성 품질**
   - 적절한 길이 → 맥락 보존
   - LLM 컨텍스트 윈도우 효율적 활용

**RAG 영향:**
```
❌ 2000자 청크:
   - 임베딩 벡터에 너무 많은 정보 포함
   - 검색 시 관련성 점수 분산
   - LLM에 불필요한 정보 전달

✅ 500자 청크:
   - 적절한 정보량
   - 검색 정확도 향상
   - LLM 컨텍스트 효율적 활용
```

---

### 단계 8: 스키마 정리

**방법:**
```python
1. null 값 제거
2. 선택적 필드는 값이 있을 때만 포함
   - article_id, article_title, sub_chunk
```

**이유:**
- DB 삽입 시 스키마 일관성
- 검색 결과 표시 시 null 값으로 인한 오류 방지
- 메타데이터 활용 시 안정성

**스키마 구조:**
```json
// Law 모드
{
  "id": "minlaw_0001",
  "title": "상속개시의 원인 제997조",
  "text": "...",
  "source": "1. 민법 상속편.pdf",
  "category": "법령_민법_상속",
  "article_id": "제997조",           // 선택적
  "article_title": "상속개시의 원인", // 선택적
  "sub_chunk": 1                     // 선택적 (분할된 경우만)
}

// Simple 모드
{
  "id": "tax1_0001",
  "title": "...",
  "text": "...",
  "source": "2. 국세청-상속·증여 세금상식1.pdf",
  "category": "세금_안내"
}
```

---

## 3. RAG 검색 품질에 미치는 영향

### 3.1 임베딩 벡터 품질

**정제 전:**
```
텍스트: "상속\n\n민법권\x07"
임베딩: [0.1, 0.2, 0.3, ...] (왜곡된 벡터)
```

**정제 후:**
```
텍스트: "상속권"
임베딩: [0.5, 0.6, 0.7, ...] (정확한 벡터)
```

### 3.2 검색 정확도

**정제 전:**
- 단어 분리 → 키워드 매칭 실패
- 헤더/푸터 포함 → 관련성 점수 하락
- 제어 문자 → 노이즈

**정제 후:**
- 단어 복원 → 정확한 키워드 매칭
- 본문만 포함 → 관련성 점수 향상
- 깨끗한 텍스트 → 정확한 검색

### 3.3 생성 품질

**적절한 청크 크기:**
- 500자 → 적절한 맥락 보존
- LLM이 이해하기 쉬운 길이

**너무 긴 청크:**
- 불필요한 정보 포함
- LLM이 핵심 정보를 놓칠 수 있음

**너무 짧은 청크:**
- 맥락 손실
- LLM이 정확한 답변 생성 어려움

---

## 4. 법률 문서 특화 처리

### 4.1 조문 단위 청킹

**이유:**
- 법조문은 조문 단위가 의미 단위
- 사용자 질문도 보통 조문 단위
- 예: "제1112조에 대해 알려줘"

**효과:**
- 검색 정확도 향상
- 관련성 높은 결과 반환

### 4.2 법률 용어 보호

**예시:**
- "100분의 10" → 보호 (정상 패턴)
- "2분의 12" → "2분의 1\n\n2" (분리)

**이유:**
- 법률 문서의 특수 표현 정확도 보장
- 검색 시 정확한 법률 용어 매칭

### 4.3 날짜 형식 유지

**예시:**
- "2024.1.1." (원본 유지)
- "'24.5.10." (원본 유지)

**이유:**
- 법령 참조 시 정확성 필요
- 원본 형식 유지로 법령 인용 정확도 보장

### 4.4 각주/부칙 분리

**방법:**
- 긴 각주(80자 이상)는 본문과 분리
- 본문이 짧으면 각주 포함

**이유:**
- 본문과 각주는 다른 성격
- 검색 시 본문 우선, 각주는 보조 정보

---

## 5. 정제 과정 요약

```
PDF 파일
  ↓
[1] 텍스트 추출 (PyMuPDF)
  ↓
[2] 제어 문자 제거
  ↓
[3] 한글 단어 중간 개행 복원
  ↓
[4] PDF 헤더/푸터 제거
  ↓
[5] 특수 패턴 정리
  ↓
[6] 청킹 (Law/Simple 모드)
  ↓
[7] 길이 제한 (500자)
  ↓
[8] 스키마 정리
  ↓
JSONL 파일 (DB 삽입 준비 완료)
```

---

## 6. 검증 방법

### 6.1 자동 검증 스크립트

```bash
python3 validate_processed_data.py
```

**검증 항목:**
- 제어 문자 체크
- 텍스트 길이 체크 (20-500자)
- 특수 패턴 체크
- JSON 형식 유효성
- 스키마 일관성
- null 값 체크

### 6.2 수동 검증

- 랜덤 샘플 확인
- 실제 검색 테스트
- 생성 품질 확인

---

## 7. 결론

이 정제 과정은 RAG 시스템의 검색 정확도와 생성 품질을 최적화하기 위해 설계되었습니다. 특히 법률 문서의 특성을 고려하여 조문 단위 청킹, 법률 용어 보호 등의 특화 처리를 포함하고 있습니다.

**핵심 원칙:**
1. 의미 단위 보존
2. 노이즈 제거
3. 적절한 청크 크기
4. 법률 문서 특성 반영

